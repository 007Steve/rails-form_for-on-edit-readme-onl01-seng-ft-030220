# form_for on Edit

Objectives

1. Define the problem with form_tag on edit
2. Define the problem with update
3. Distinguish between form_for and form_tag
4. Correctly pass an instance to form_for
5. Describe a form_builder
6. Call input methods on a form_build to generate smart form controls
7. Describe the options available to form_for
8. Use the nested params naming convention object[attribute]
9. Mass assign the object[attribute] params key to update

10.? understand strong params (possibly, I'd love to ignore this)

## Notes

recap are form_tag based edit and update code.

let's talk about the issues with this code before we learn about a more elegant pattern for building activerecord-based forms.

Problems with Edit Form

our form_tag isn't using any information about @post to make assumptions about our form action and method. @post.new_record? vs @post.persisted? If AR knows whether it's a new post or an existing post, and we have an existing post, isn't it obvious that the form's method should be PUT and the URL should be post_path for @post?
repitition of @post and post everywhere. our entire form consitantly says that we're dealing with a post, both when we name a field, post_title, and then when we call a method on @post.
repetition of attribute names in the input tags, we're naming the field after the same attribute we're reading to set the value of the field.
Problems with Update

manual assignment is well manual. repitition of attribute we're writing too and the corresponding key in params, title= and params[:post_title]
with update, we have to repeat the same information but now as keys in a hash. update(:title => params[:post_title]). No way to just pass params in because it has more information, such as ID, then we can mass assign. If only we could ask params for just the attributes relating to a post?
The biggest offender though, is that this code violates a principal of beauty, proportion. Let's say we needed to add a new field to our form, like an attribute author_name. Conceptually, that's 1 change. How many changes do we need to make to our form and controller? We need to update the form and then we need to update the controller. One conceptual change should mean one code change. That would be a beatiful proportion.

form_for to the rescue

form_tag family of helpers - simply generate html, no knowledge, not smart. helpful and shorter than html, but we can do better.

form_for family of helpers are bound to the activerecord object the form relates too. that means every time we build a form tag or an input tag, we can make assumptions based on the model itself. it's really cool, watch.

form_for(@post) do |form_builder|

end

when we build a form, we pass in the activerecord instance the form is wrapping. form_for will yield an abstract object called a form builder which is an instance of ActionView::FormBuilder to the block we pass it.

within the block of form_for, we can use the form_builder to generate inputs and form controls based on the @post object we passed form_for.

form_for(@post) do |form_builder| <%= form_builder.text_field :title %> end

that magic line generates the following html for our edit form.

we never had to mention @post or post_title or @post.title. everything was automagically generated by calling a method, text_field, on the form_builder object.

lets break down the line that generates the text_field for the post titles.

form_builder.text_field is a method that form_builder responds too, we can even look it up in documentation.

it's required argument is the attribute name of @post that we want to generate a text_field for, namely, the title attribute. That's all we have to say. The form builder knows what to do from there.

let's add a submit button to the form

form_for(@post) do |form_builder| <%= form_builder.text_field :title %> <%= form_builder.submit %> end

refersh your browser. notice something amazing? we never specified the value or text of the submit button yet hte button knows we're updating a post? how? the magic form builder.

lets go back to update and add a line to raise params.inspect because our form_builder has named our fields differently.

we used to have post_title now we have post[title]. what could possibly be the meaning of this? this is just a string value for an html value, so nothing about 'post[title]' is ruby, but there is a magical rails convention here, what does post[title] look like in terms of ruby? what do you think the sturcture of params will be now?

lets submit the form and see

params is now a nested hash with a key post that contains a hash with the key title. Why is this useful? well for one, it is a better structure. adding a top-level key, post, to params, allows params to group attributes that relate to each other. The post attributes from the form are on a different level of the params hash.

second, with that, params[:post] returns a nice hash {:title => "Post Title"}. Why is that useful? Becasue we can mass-assign the updated post attributes to update with @post.update(params[:post]) (we have to account for strong parameters, either telling them to shut it off, providing code, or teaching them about it here).

That's pretty nice.

Let's go back to our form and add content, the exact situation we said made our code disproportionate earlier. before, adding a new field required two update, one to the form and one to the controller action. watch what happens now.

form_for(@post) do |form_builder| <%= form_builder.text_field :title %> <%= form_builder.text_area :content %> <%= form_builder.submit %> end

submit the form and we don't need to update the controller action because of mass-assignment.

That in a nutshell is how form_for works.

other form builders, select_tag, hidden_tag, etc.
options to pass to form_for, most important is URL

<a href='https://learn.co/lessons/rails-form_for-on-edit-readme' data-visibility='hidden'>View this lesson on Learn.co</a>
